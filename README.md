# Test suite for betchmarking SCA tools
This test suite consists of 13 Maven projects. The first project serves as a baseline for evaluation, while the remaining projects implement 12 distinct attack strategies. These strategies can be categorized into two main groups: manifest feature modifications and dependency modifications. Manifest feature modifications are limited to alterations within a manifest file and rely on Maven for the installation and resolution of dependencies. On the other hand, dependency modifications cover manual installation of or bundling dependencies, where Maven does not automatically download and install dependencies, but instead adds pre-compiled dependencies to system folders. In the suite, scenarios 1 to 5 focus on manifest feature modifications, and scenarios 6 to 12 implement dependency modifications. Below, we provide a short description for each project within the test suite.
## Baseline: 
The baseline test case where dependencies are unmodified inside a Maven project's manifest file (_pom.xml_). In this setup, all dependencies are explicitly listed inside the _<dependencies/>_ section, with their group ID, artifact ID, and version specified directly inside each _<dependency/>_ tag. Maven's automatic resolution mechanism ensures that transitive dependencies are included in the project as required. This test case serves as the foundation for evaluating the impact of subsequent metadata manipulations, providing a clear reference point for comparison.
## Attack Scenario 1: Version as variable.
Dependency versions are defined as variables inside the _<properties/>_ section of the manifest file, while group IDs and artifact IDs remain listed directly inside each _<dependency/>_ tag. 
## Attack Scenario 2: Dependency management.
Dependencies with their group IDs, artifact IDs, and versions are initially declared inside the _<dependencyManagement/>_ section of the manifest file. However, the _<dependencyManagement/>_ section is a declaration, not an invocation of dependencies. Therefore, within the subsequent _<dependencies/>_ section, dependencies are then invoked without specifying their versions. Instead, the project relies on the version declarations provided in the _<dependencyManagement/>_ section to resolve and include the dependencies. 
## Attack Scenario 3: Profile.
All dependencies are listed inside the default profile inside the _<profiles/>_ section of the manifest file. Within this profile, dependencies are included with their respective group IDs, artifact IDs, and versions. The _<profiles/>_ section in a Maven manifest file allows for defining sets of configuration values, including modifying or adding dependencies, that can be activated or deactivated selectively during the project-building process. 
## Attack Scenario 4: Parent and child manifest (version as variable).
In this test case, the Maven project has a modular structure where dependencies and their versions are managed separately. Within the parent manifest file, dependency versions are declared inside the _<properties/>_ section. Meanwhile, in the child manifest file representing an individual module, dependencies are invoked indirectly using variables defined in the parent manifest. This modular approach is normally utilized for maintainability and facilitates easier version control, as changes to dependency versions can be applied universally across all modules by updating the parent manifest. 
## Attack Scenario 5: Parent and child manifest (group ID as variable).
Here, similar to Attack Scenario 5, the Maven project has a modular structure. However, rather than specifying versions of all dependencies inside the _<properties/>section of the parent manifest, group IDs are defined instead. While this modification may raise suspicion as it is quite unconventional, it is permissible within the Maven framework. Maven permits the use of variables throughout the manifest, and an adversary might employ this technique to intentionally confuse an SCA tool. 
## Attack Scenario 6: Manually installed with a modified version.
Dependencies are most often manually installed into the project because of patching. Patching a dependency traditionally involves modifying its source code before integrating it into a project. However, to investigate the constraints of metadata-reliant approaches, we refrained from modifying any dependency source code. Instead, we downloaded the jar files directly from the Maven Central Repository. Using the _mvn install:install-file_ command, we installed these dependencies to the project with a slight modification by appending a random word, such as "patch," to its version. However, it is important to note that due to the manual installation, the patched dependencies did not automatically include their transitive dependencies. 
## Attack Scenario 7: Manually installed with a modified group ID.
Similar to the previous test case, we continued to manually install dependency jars into the project. However, we introduced a deliberate typo in the group ID of each dependency. For instance, instead of using the correct group ID _org.springframework.boot_, we intentionally misspelled it as _org.springframeworkboot_. The rationale behind this modification was to simulate a scenario where an adversary intentionally introduces subtle errors in the metadata of manually included dependencies. Such deliberate misspellings could potentially cause SCA tools to overlook the dependency, all while evading detection. 
## Attack Scenario 8: Manually installed with a non-vulnerable version.
Similar to the previous two test cases, we manually install dependency jars into the project. However, instead of making slight modifications to a dependency's version, we take a more drastic approach by completely replacing it with either a non-vulnerable version or, if such a version is unavailable, with the latest version. We try to simulate a scenario where an adversary intentionally includes a vulnerable dependency while evading detection through metadata manipulation — specifically, by changing dependencies' versions. 
## Attack Scenario 9: Uber-JAR.
All direct and transitive dependencies are bundled into a single jar file, commonly known as an Uber-JAR, with a random name. This file is then manually installed into the project, including all necessary dependencies inside a single package. To achieve this, we used the Maven Assembly Plugin to create an Uber-JAR with dependencies. 
## Attack Scenario 10: Shaded Uber-JAR.
Shading is a technique commonly used by Java developers to avoid incompatibility issues between dependencies by repackaging them and modifying their package and class names. This process transforms original class names, such as _org.package.class_, into a shaded version — _org.shaded.package.class_. In this test case, we shaded all direct and transitive dependencies inside the project. To accomplish this, we used the Maven Shade Plugin, which created a shaded Uber-JAR containing all dependencies. This shaded Uber-JAR was then manually installed into the project. 
## Attack Scenario 11: Bare Uber-JAR.
In this test case, we reused an Uber-JAR file with dependencies from a previous test case (Attack Scenario 10). However, we striped away all metadata typically relied upon by SCA tools. This included removing _pom.xml_ files, _pom.properties_ files, and the entirety of the META-INF folder. We also updated the timestamps of all files within this binary. This modified Uber-JAR, with missing metadata and with altered file timestamps, was then manually installed into the project.
## Attack Scenario 12: Uber-JAR with modified metadata.
In this test case, we again reused an Uber-JAR with dependencies from Attack Scenario 10. However, rather than removing metadata entirely, we modified it. In each existing _pom.xml_ and _pom.properties_ files, we strategically changed the version of a vulnerable dependency. Specifically, we replaced the vulnerable version with a non-vulnerable, or if such a version was not available, with the latest version. Rather than overwriting entire _pom.xml_ files by downloading them from the Maven Central Repository, we focused only on modifying the version information within the existing files. This modification aimed to simulate a scenario where an adversary manipulates metadata to conceal vulnerabilities within dependencies.
