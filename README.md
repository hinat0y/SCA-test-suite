# Test suite for betchmarking SCA tools
This test suite consists of 13 Maven projects. The first two projects serve as baselines for evaluation, while the remaining projects implement 11 distinct attack strategies. The designed attack strategies can be categorized into three groups: manifest feature modifications, bundling modifications, and dependency modifications. Manifest feature modifications are limited to alterations within a manifest file and
rely on Maven for the installation and resolution of dependencies. Bundling modifications explore techniques where multiple dependencies are compressed into a single file, known as an Uber-JAR, and included inside a project. Lastly, dependency modifications cover the manual installation of dependencies. Instead of Maven automatically downloading a dependency, it adds a pre-compiled dependency to system folders.

_Manifest feature modifications:_
## Attack Scenario 1: 
Version as variable. Dependency versions are defined as variables inside the _properties_ section of the manifest file, while group IDs and artifact IDs remain listed directly inside each _dependency_ tag.
## Attack Scenario 2: 
Dependency management. Dependencies with their group IDs, artifact IDs, and versions are initially declared inside the _dependencyManagement_ section of the manifest file. However, the _dependencyManagement_ section is a declaration, not an invocation of dependencies. Therefore, within the subsequent _dependencies_ section, dependencies are then invoked without specifying their versions. Instead, the project relies on the version declarations provided in the _dependencyManagement_ section to resolve and include the dependencies. 
## Attack Scenario 3: Profiles. 
All dependencies are listed inside the default profile inside the _profiles_ section of the manifest file. Within this profile, dependencies are included with their respective group IDs, artifact IDs, and versions. The _profiles_ section in a Maven manifest file allows for defining sets of configuration values, including modifying or adding dependencies, that can be activated or deactivated selectively during the project-building process. 
## Attack Scenario 4: 
Parent and child manifest (version as variable). In this attack scenario, the Maven project has a modular structure where dependencies and their versions are managed separately. Within the parent manifest file, dependency versions are declared inside the _properties_ section. Meanwhile, in the child manifest file representing an individual module, dependencies are invoked indirectly using variables defined in the parent manifest. This modular approach is normally utilized for maintainability and facilitates easier version control, as changes to dependency versions can be applied universally across all modules by updating the parent manifest. 
## Attack Scenario 5: 
Parent and child manifest (group ID as variable). Here, similar to Attack Scenario 4, the Maven project has a modular structure. However, rather than specifying versions of all dependencies inside the _properties_ section of the parent manifest, group IDs are defined instead. While this modification may raise suspicion as it is quite unconventional, it is permissible within the Maven framework. Maven permits the use of variables throughout the manifest, and an adversary might employ this technique to intentionally confuse an SCA tool. 

_Bundling modifications:_
## Attack Scenario 6: 
Uber-JAR. All direct and transitive dependencies are bundled into a single jar file, commonly known as an Uber-JAR, with a random name. This file is then manually installed into the project, including all necessary dependencies inside a single package. To achieve this, we used the Maven Assembly Plugin to create an Uber-JAR with dependencies. 
## Attack Scenario 7: 
Shaded Uber-JAR. Shading is a technique commonly used by Java developers to avoid incompatibility issues between dependencies by repackaging them and modifying their package and class names. This process transforms original class names, such as _org.package.class_, into a shaded version — _org.shaded.package.class_. In this attack scenario, we shaded all direct and transitive dependencies inside the project. To accomplish this, we used the Maven Shade Plugin, which created a shaded Uber-JAR containing all dependencies. This shaded Uber-JAR was then manually installed into the project. 
## Attack Scenario 8: 
Bare Uber-JAR. In this attack scenario, we reused an Uber-JAR file with dependencies from a previous attack scenario (Attack Scenario 6). However, we striped away all metadata typically relied upon by SCA tools. This included removing _pom.xml_ files, _pom.properties_ files, and the entirety of the _META-INF_ folder. We also updatied the timestamps of all files within this binary. This modified Uber-JAR, with missing metadata and with altered file timestamps, was then manually installed into the project.
## Attack Scenario 9: 
Uber-JAR with modified metadata. In this attack scenario, we again reused an Uber-JAR with dependencies from Attack Scenario 6. However, rather than removing metadata entirely, we modified it. In each existing _pom.xml_ and _pom.properties_ file, we strategically changed the version of a vulnerable dependency. Specifically, we replaced the vulnerable version with a non-vulnerable, or if such a version was not available, with the latest version. Rather than overwriting entire _pom.xml_ files by downloading them from the Maven Central Repository, we focused only on modifying the version information within the existing files. This modification aimed to simulate a scenario where an adversary manipulates metadata to conceal vulnerabilities within dependencies.

_Dependency modifications:_
## Attack Scenario 10: Manually installed with a modified group ID. 
Dependencies are most often manually installed into the project because of patching. Patching a dependency traditionally involves modifying its source code before integrating it into a project. However, to investigate the constraints of metadata-reliant approaches, we refrained from modifying any dependency source code. Instead, we downloaded the jar files directly from the Maven Central Repository. Using the _mvn install:install-file_ command, we installed these dependencies to the project. However, we introduced a deliberate typo in the group ID of each dependency. For instance, instead of using the correct group ID _org.springframework.boot_, we intentionally misspelled it as _org.springframeworkboot_. The rationale behind this modification was to simulate a scenario where an adversary intentionally introduces subtle errors in the metadata of manually included dependencies. Such deliberate misspellings could potentially cause SCA tools to overlook the dependency, all while evading detection. It is important to note that due to the manual installation, the installed dependencies did not automatically include their transitive dependencies.
## Attack Scenario 11: Manually installed with a non-vulnerable version. 
Similar to the previous attack scenario, we manually installed dependency jars into the project. However, instead of making slight modifications to a dependency's group ID, we replace the dependency's version with either a non-vulnerable version or, if such a version is unavailable, with the latest version. We try to simulate a scenario where an adversary intentionally includes a vulnerable dependency while evading detection through metadata manipulation — specifically, by changing dependencies' versions.